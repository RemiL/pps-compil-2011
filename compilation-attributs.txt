/* MOMENTS DE DOUTE MARQUES PAR ????? */

/*
Validité : valide()
Un environnement contient un objet : bool contains(env,obj)
*/

/* Declarations et validités : 
type() = type d'une variable ou d'une entité

Déclarations de types
decl() = déclarations synthétisées
declh() = déclarations héritées

Déclarations de variables
decv() = déclarations synthétisées
decvh() = déclarations héritées

Valeur
value() = valeur d'un variable ou d'un objet
value() = NIL si non initialisé (warning?????)
*/

/* signatures de chaque classe et validité : 
methodes() = méthodes appartenant à une classe
*/

/***** liste de definition des classes ******/
----- S : LDefClass Bloc
valide(S) = valide(LDefClass) && valide(Bloc)
decl(S) = [Entier, Chaine, Boolean]//????? Ajout du type Boolean. Pas de float, pas de char ?
declh(LDefClass) = decl(S)
declh(Bloc) = decl(S) + decl(LDefClass)

----- LDefClass0 : LDefClass1 DefClass
valide(LDefClass0) = valide(LDefClass1) && valide(DefClass)
decl(LDefClass0) = decl(LDefClass1) + decl(DefClass)
declh(LDefClass1) = declh(LDefClass0) //+ decl(DefClass) ?????
declh(DefClass) = declh(LDefClass1)


----- LDefClass : DefClass //liste de definition de classes
valide(LDefClass) = valide(DefClass)
declh(DefClass) = declh(LDefClass)
decl(LDefClass) = decl(DefClass)


----- DefClass : CLASS ID_CLASS '(' LParamOpt ')' ExtendsOpt InitBlocOpt IS Corps
//le nom de la classe n'existe pas encore, la liste des parametres du constructeur est valide, le reste aussi, et la classe mère existe (s'il y a heritage).
valide(DefClass) = !contains(declh(DefClass), ID_CLASS.lexval) && valide(LParamOpt) && valide(ExtendsOpt) && valide(InitBlocOpt) && valide(Corps) && if(type(ExtendsOpt) != EPS) then contains(declh(DefClass),type(ExtendsOpt))
decl(DefClass) = ID_CLASS.lexval
declh(LParamOpt) = declh(DefClass) + ID_CLASS.lexval
declh(ExtendsOpt) = declh(DefClass) //sans l'ID_CLASS pour ne pas heriter de soi meme
declh(InitBlocOpt) = declh(DefClass) + ID_CLASS.lexval
declh(Corps) = declh(DefClass) + ID_CLASS.lexval
//TODO attributs de la classe utiles dans InitBloc
//TODO heritage

/****** liste de parametres du constructeur ******/
----- LParamOpt : LParam
//valide, declh, decv TODO

----- LParamOpt :


----- LParam0 : Param ',' LParam1
valide(LParam0) = valide(Param) && valide(LParam1)
declh(LParam1) = declh(LParam0)
declh(Param) = declh(LParam0)
decv(LParam0) = decv(Param) + decv(LParam1)

//????? peut-on faire class A(Entier i := 3, Entier j := x){... ? Et class A(Entier j := x, Entier x := 3){... ? si oui, voir decvh.

----- LParam : Param
valide(LParam) = valide(Param)
declh(Param) = declh(LParam)
decv(LParam) = decv(Param)

----- LParam : LParamInit
valide(LParam) = valide(LParamInit)
declh(LParamInit) = declh(LParam)
decv(LParamInit) = declv(LParam)

----- LParamInit0 : LParamInit1 ',' ParamInit
valide(LParamInit0) = valide(ParamInit) && valide(LParamInit1)
declh(LParamInit1) = declh(LParamInit0)
declh(ParamInit) = declh(LParamInit0)
decv(LParamInit0) = decv(LParamInit1) + decv(ParamInit)

----- LParamInit : ParamInit
valide(LParamInit) = valide(ParamInit)
declh(ParamInit) = declh(LParamInit)
decv(LParamInit) = decv(ParamInit)

----- Param : ID ':' ID_CLASS
valide(Param) = contains(declh(Param, ID0))
type(Param) = ID_CLASS.lexval
decv(Param) = ID.lexval
value(ID1) = NIL

----- ParamInit : ID ':' ID_CLASS AFF ExprSansAffect //exemple: Entier : reponse := 42
//REVOIR
valide(ParamInit) = contains(declh(Paraminit, ID0)) && type(E) == ID0.lexval && value(E) != NIL
declh(E) = declh(ParamInit)
type(ParamInit) = ID0.lexval
decv(ParamInit) = ID1.lexval
value(ID1) = value(E)

/******** Heritage **********/
----- ExtendsOpt : EXTENDS AppelConstr
valide(ExtendsOpt) = valide(AppelConstr) && contains(declh(ExtendsOpt), type(AppelConstr)) ?????
declh(AppelConstr) = declh(ExtendsOpt)
type(ExtendsOpt) = type(AppelConstr)
//TODO appeler super() dans le constructeur de la classe fille quoi qu'il arrive (ne fait rien s'il n'y a pas d'heritage)
//TODO heriter des attributs et des methodes

----- ExtendsOpt :
valide(ExtendsOpt) = true
type(ExtendsOpt) = EPS

/******** Constructeur *********/
----- AppelConstr : ID_CLASS '(' LArgOpt ')'
valide(AppelConstr) = valide(LArgOpt) && contains(declh(AppelConstr), ID_CLASS)
type(AppelConstr) = ID_CLASS.lexval
//TODO surement plein de choses en rapport avec l'heritage, comme passer les valeurs des attributs

----- InitBlocOpt : '{' LAffectOpt '}' //instructions dans le constructeur
valide(InitBlocOpt) = valide(LAffectOpt)
declh(LAffectOpt) = declh(InitBlocOpt)
//TODO methode constructeur qui appelle un super sur rien ou sur la classe mere, initialiser les attributs initalises, et ensuite InitBloc

----- InitBlocOpt :

----- LAffectOpt : LAffect    // liste d'affectation optionnelle
valide(LAffectOpt) = valide(LAffect)
declh(LAffect) = declh(LAffect)
// ????? impossible de déclarer une variable locale pour des calculs dans le constructeur...

----- LAffectOpt :

----- LAffect0 : LAffect1 ';' Affect
valide(LAffect0) = valide(LAffect1) && valide(Affect)
declh(LAffect1) = declh(LAffect0)
declh(Affect) = declh(LAffect0)

----- LAffect : Affect
valide(LAffect) = valide(Affect)
declh(Affect) = declh(LAffect)

----- Affect : ID AFF ExprSansAffect
//REVOIR
valide(LAffect) = valide(ID) && valide(Expr) && type(Selection) == type(Expr)
declh(Expr) = declh(Affect)

----- Affect : Selection AFF ExprSansAffect


/******* corps de la classe ***************/
----- Corps : '{' LDeclAttrOpt LDeclMethOpt '}'        // corps d'une classe
valide(Corps) = valide(LDeclAttrOpt) && valide(LDeclMethOpt)
declh(LDeclAttrOpt) = declh(Corps)
declh(LDeclMethOpt) = declh(Corps)
decv(Corps) = decv(LDeclAttrOpt)//TODO etendre au dessus et aux methodes

----- LDeclAttrOpt : LDeclAttr        // liste de déclaration d'attributs optionnelle
valide(LDeclAttrOpt) = valide(LDeclAttr)
declh(LDeclAttr) = declh(LDeclAttrOpt)
decv(LDeclAttrOpt) = decv(LDeclAttr)

----- LDeclAttrOpt : 


----- LDeclMethOpt : LDeclMeth        // liste de déclaration de méthodes optionnelle
valide(LDeclMethOpt) = valide(LDeclMeth)
declh(LDeclMeth) = declh(LDeclMethOpt)
//TODO methodes comme les attributs, un peu

----- LDeclMethOpt :


----- LDeclAttr0 : LDeclAttr1 ';' DeclAttr    // liste de déclaration d'un attribut de classe
valide(LDeclAttr0) = valide(LDeclAttr1) && valide(DeclAttr)
declh(LDeclAttr1) = declh(LDeclAttr1)
declh(DeclAttr) = declh(LDeclAttr0)
decv(LDeclAttr0) = decv(LDecAttr1) + decv(DeclAttr)

----- LDeclAttr : DeclAttr
valide(LDeclAttr) = valide(DeclAttr)
declh(LDeclAttr) = declh(DeclAttr)
decv(LDeclAttr) = decv(DeclAttr)

----- DeclAttr : STATIC DeclA    // déclaration d'un attribut statique ou pas statique (de classe)
valide(DeclAttr) = valide(DeclA)
declh(DeclA) = declh(DeclAttr)
decv(DeclAttr) = decv(DeclA)
//TODO ne pas oublier de gerer les attributs statiques et override, comme les methodes d'ailleurs

----- DeclAttr : DeclA
valide(DeclAttr) = valide(DeclA)
declh(DeclA) = declh(DeclAttr)
decv(DeclAttr) = decv(DeclA)

----- DeclA : VARIABLE ID ':' ID_CLASS InitOpt   // déclaration d'un attribut variable
valide(DeclA) = valide(InitOpt) && contains(declh(DeclA), ID_CLASS.lexval)
type(ID0) = ID_CLASS.lexval
value(ID0) = value(InitOpt)
decv(DeclA) = ID.lexval

----- DeclA : VAL ID ':' ID_CLASS InitOpt // déclaration d'un attribut constant
valide(DeclA) = valide(InitOpt) && contains(declh(DeclA), ID_CLASS.lexval) && value(InitOpt) = (EPS || ID0.lexval)
type(ID) = ID_CLASS.lexval
value(ID) = value(InitOpt)
decv(DeclA) = ID.lexval
//TODO constant

----- InitOpt : AFF ExprSansAffect
valide(InitOpt) = valide(ExprSansAffect)
type(InitOpt) = type(ExprSansAffect)
value(InitOpt) = value(ExprSansAffect)

----- InitOpt : 
valide(InitOpt) = true
type(InitOpt) = EPS
value(InitOpt) = NIL

----- LDeclMeth0 : LDeclMeth1 DeclMeth
valide(LDeclMeth0) = valide(LDeclMeth1) && valide(DeclMeth)
methodes(LDeclMeth0) = methodes(LDeclMeth1) + methodes(DeclMeth)
declh(LDeclMeth1) = declh(LDeclMeth0)
declh(DeclMeth) = declh(LDeclMeth0)

----- LDeclMeth : DeclMeth
valide(LDeclMeth) = valide (DeclMeth)
declh(DeclMeth) = decl(LDeclMeth0)

----- DeclMeth : Def ID '(' LParamOpt ')' RETURNS ID_CLASS IS Bloc
valide(DeclMeth)  = valide(LParamOpt) && valide(Bloc) && contains(declh(DeclMeth), ID_CLASS.lexval) && (type(Bloc) == ID_CLASS.lexval)

----- Def : DEF STATIC
valide(Def) = true;
//TODO ne contient pas de this

----- Def : DEF
valide(Def) = true;

----- Def : DEF OVERRIDE
valide(Def) = //TODO existe dans les methodes de la classe mere

----- Bloc : '{' Lexpr '}'
valide(Bloc) = valide(Lexpr)
type(Bloc) = type(Lexpr)
declh(Lexpr) = declh(Bloc)

----- Bloc : '{' LDeclA IS Lexpr '}'
valide(Bloc) = valide(LDeclA ) && valide(Lexpr)
type(Bloc) = type(Lexpr)
declh(Lexpr) = declh(Bloc)
declh(LDeclA) = declh(Bloc)

----- LDeclA : LDeclA ';' DeclA        // liste de déclaration d'attribut non statique

----- LDeclA : DeclA


----- LExpr0 : LExpr1 ';' Expr        // liste d'expression d'un bloc
valide(LExpr0) = valide(LExpr1) && valide(Expr)
declh(LExpr1) = declh(LExpr0)
declh(Expr) = declh(Lexpr0)
type(LExpr0) = type(Expr)

----- LExpr : Expr
valide(Lexpr) = valide(E)
type(Lexpr) = type(E)
declh(E) = declh(Lexpr)

----- BlocExpr : Expr


----- BlocExpr : Bloc

----- Expr : ExprSansAffect

----- Expr : Affect

----- ExprSansAffect : IfThenElse

----- ExprSansAffect : Selection

----- ExprSansAffect : STRING

----- ExprSansAffect : CSTE

----- ExprSansAffect : NOUVEAU ID_CLASS '(' LArgOpt ')'

----- ExprSansAffect : EnvoiMsg

----- ExprSansAffect : ExprSansAffect '+' ExprSansAffect

----- ExprSansAffect : ExprSansAffect '-' ExprSansAffect

----- ExprSansAffect : ExprSansAffect '*' ExprSansAffect

----- ExprSansAffect : ExprSansAffect '/' ExprSansAffect

----- ExprSansAffect : '+' ExprSansAffect %prec PREC_UNAIRE

----- ExprSansAffect : '-' ExprSansAffect %prec PREC_UNAIRE

----- ExprSansAffect : ExprSansAffect RELOP ExprSansAffect

----- ExprSansAffect : '(' Expr ')'

----- ExprSelec : '(' Expr ')'
valide(ExprSelec) = valide(Expr)
//TODO blablabla

----- ExprSelec : CSTE
type(ExprSelec) = Entier
value(ExprSelec) = CSTE.lexval
valide(ExprSelec) = true


----- ExprSelec : STRING
type(ExprSelec) = Chaine
value(ExprSelec) = STRING.lexval
valide(ExprSelec) = true

----- ExprSelec : ID
valide(ExprSelec) = contains(decv(ExprSelec), ID)//decvh ?????
type(ExprSelec) = type(ID)
value(ExprSelec) = value(ID)

----- ExprSelec : Selection
valide(ExprSelec) = valide(Selection)
type(ExprSelec) = type(Selection)
value(ExprSelec) = value(Selection)

----- ExprSelec : EnvoiMsg
valide(ExprSelec) = valide(EnvoiMsg)
type(ExprSelec) = type(EnvoiMsg)
value(ExprSelec) = value(EnvoiMsg)

----- Selection : ExprSelec '.' ID
valide(ExprSelec) = //TODO
type(ExprSelec) = type(ID)
value(ExprSelec) = value(ID)

----- EnvoiMsg : ExprSelec '.' ID '(' LArgOpt ')'     // envoi d'un message simple ou appel à une fonction statique

----- EnvoiMsg : ID_CLASS '.' ID '(' LArgOpt ')'

----- IfThenElse : IF Expr THEN BlocExpr0 ELSE BlocExpr1
valide(IfThenElse) = valide(Expr) && valide (BlocExpr0) && valide(BlocExpr1) && type(Expr) == boolean
declh(Expr) = declh(IfThenElse)
declh(BlocExpr0) = declh(IfThenElse)
declh(BlocExpr1) = declh(IfThenElse)

----- LArgOpt : LArg    // liste d'arguments optionnelle
valide(LArgOpt) = valide(LArg)
declh(LArg) = declh(LArgOpt)

----- LArgOpt :


----- LArg0 : LArg1 ',' Expr    // liste d'arguments
valide(LArg0) = valide(LArg1) && valide(E)
declh(LArg1) = declh(LArg0)
declh(E) = declh(LArg0)

----- LArg : Expr
valide(LArg) = valide(Expr)
declh(Expr) = declh(LArg)


/* ******* THE END ******* EOF ****** */
